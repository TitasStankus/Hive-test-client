// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMONS_HIVE_COMMONS_FLATBUFFERS_GENERATED_H_
#define FLATBUFFERS_GENERATED_COMMONS_HIVE_COMMONS_FLATBUFFERS_GENERATED_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace HIVE {
namespace Commons {
namespace Flatbuffers {
namespace Generated {

struct Vec3;

struct Vec4;

struct BoundingBox;
struct BoundingBoxBuilder;
struct BoundingBoxT;

struct Node;
struct NodeBuilder;
struct NodeT;

struct Generic;
struct GenericBuilder;
struct GenericT;

struct Robot;
struct RobotBuilder;
struct RobotT;

struct Headset;
struct HeadsetBuilder;
struct HeadsetT;

struct Presenter;
struct PresenterBuilder;
struct PresenterT;

struct Geometry;
struct GeometryBuilder;
struct GeometryT;

struct Observer;
struct ObserverBuilder;
struct ObserverT;

struct Owner;
struct OwnerBuilder;
struct OwnerT;

struct MoveTo;
struct MoveToBuilder;
struct MoveToT;

struct Sleep;
struct SleepBuilder;
struct SleepT;

struct Command;
struct CommandBuilder;
struct CommandT;

struct Entity;
struct EntityBuilder;
struct EntityT;

struct Payload;
struct PayloadBuilder;
struct PayloadT;

struct State;
struct StateBuilder;
struct StateT;

enum SubscriptionRate : int8_t {
  SubscriptionRate_None = 0,
  SubscriptionRate_Full = 1,
  SubscriptionRate_Half = 2,
  SubscriptionRate_Quarter = 3,
  SubscriptionRate_MIN = SubscriptionRate_None,
  SubscriptionRate_MAX = SubscriptionRate_Quarter
};

inline const SubscriptionRate (&EnumValuesSubscriptionRate())[4] {
  static const SubscriptionRate values[] = {
    SubscriptionRate_None,
    SubscriptionRate_Full,
    SubscriptionRate_Half,
    SubscriptionRate_Quarter
  };
  return values;
}

inline const char * const *EnumNamesSubscriptionRate() {
  static const char * const names[5] = {
    "None",
    "Full",
    "Half",
    "Quarter",
    nullptr
  };
  return names;
}

inline const char *EnumNameSubscriptionRate(SubscriptionRate e) {
  if (::flatbuffers::IsOutRange(e, SubscriptionRate_None, SubscriptionRate_Quarter)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSubscriptionRate()[index];
}

enum OwnershipStatus : int8_t {
  OwnershipStatus_None = 0,
  OwnershipStatus_Open = 1,
  OwnershipStatus_Exclusive = 2,
  OwnershipStatus_MIN = OwnershipStatus_None,
  OwnershipStatus_MAX = OwnershipStatus_Exclusive
};

inline const OwnershipStatus (&EnumValuesOwnershipStatus())[3] {
  static const OwnershipStatus values[] = {
    OwnershipStatus_None,
    OwnershipStatus_Open,
    OwnershipStatus_Exclusive
  };
  return values;
}

inline const char * const *EnumNamesOwnershipStatus() {
  static const char * const names[4] = {
    "None",
    "Open",
    "Exclusive",
    nullptr
  };
  return names;
}

inline const char *EnumNameOwnershipStatus(OwnershipStatus e) {
  if (::flatbuffers::IsOutRange(e, OwnershipStatus_None, OwnershipStatus_Exclusive)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOwnershipStatus()[index];
}

enum CommandUnion : uint8_t {
  CommandUnion_NONE = 0,
  CommandUnion_Owner = 1,
  CommandUnion_MoveTo = 2,
  CommandUnion_Sleep = 3,
  CommandUnion_MIN = CommandUnion_NONE,
  CommandUnion_MAX = CommandUnion_Sleep
};

inline const CommandUnion (&EnumValuesCommandUnion())[4] {
  static const CommandUnion values[] = {
    CommandUnion_NONE,
    CommandUnion_Owner,
    CommandUnion_MoveTo,
    CommandUnion_Sleep
  };
  return values;
}

inline const char * const *EnumNamesCommandUnion() {
  static const char * const names[5] = {
    "NONE",
    "Owner",
    "MoveTo",
    "Sleep",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommandUnion(CommandUnion e) {
  if (::flatbuffers::IsOutRange(e, CommandUnion_NONE, CommandUnion_Sleep)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCommandUnion()[index];
}

template<typename T> struct CommandUnionTraits {
  static const CommandUnion enum_value = CommandUnion_NONE;
};

template<> struct CommandUnionTraits<HIVE::Commons::Flatbuffers::Generated::Owner> {
  static const CommandUnion enum_value = CommandUnion_Owner;
};

template<> struct CommandUnionTraits<HIVE::Commons::Flatbuffers::Generated::MoveTo> {
  static const CommandUnion enum_value = CommandUnion_MoveTo;
};

template<> struct CommandUnionTraits<HIVE::Commons::Flatbuffers::Generated::Sleep> {
  static const CommandUnion enum_value = CommandUnion_Sleep;
};

template<typename T> struct CommandUnionUnionTraits {
  static const CommandUnion enum_value = CommandUnion_NONE;
};

template<> struct CommandUnionUnionTraits<HIVE::Commons::Flatbuffers::Generated::OwnerT> {
  static const CommandUnion enum_value = CommandUnion_Owner;
};

template<> struct CommandUnionUnionTraits<HIVE::Commons::Flatbuffers::Generated::MoveToT> {
  static const CommandUnion enum_value = CommandUnion_MoveTo;
};

template<> struct CommandUnionUnionTraits<HIVE::Commons::Flatbuffers::Generated::SleepT> {
  static const CommandUnion enum_value = CommandUnion_Sleep;
};

struct CommandUnionUnion {
  CommandUnion type;
  void *value;

  CommandUnionUnion() : type(CommandUnion_NONE), value(nullptr) {}
  CommandUnionUnion(CommandUnionUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(CommandUnion_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  CommandUnionUnion(const CommandUnionUnion &);
  CommandUnionUnion &operator=(const CommandUnionUnion &u)
    { CommandUnionUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  CommandUnionUnion &operator=(CommandUnionUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~CommandUnionUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = CommandUnionUnionTraits<RT>::enum_value;
    if (type != CommandUnion_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, CommandUnion type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  HIVE::Commons::Flatbuffers::Generated::OwnerT *AsOwner() {
    return type == CommandUnion_Owner ?
      reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::OwnerT *>(value) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::OwnerT *AsOwner() const {
    return type == CommandUnion_Owner ?
      reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::OwnerT *>(value) : nullptr;
  }
  HIVE::Commons::Flatbuffers::Generated::MoveToT *AsMoveTo() {
    return type == CommandUnion_MoveTo ?
      reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::MoveToT *>(value) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::MoveToT *AsMoveTo() const {
    return type == CommandUnion_MoveTo ?
      reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::MoveToT *>(value) : nullptr;
  }
  HIVE::Commons::Flatbuffers::Generated::SleepT *AsSleep() {
    return type == CommandUnion_Sleep ?
      reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::SleepT *>(value) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::SleepT *AsSleep() const {
    return type == CommandUnion_Sleep ?
      reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::SleepT *>(value) : nullptr;
  }
};

bool VerifyCommandUnion(::flatbuffers::Verifier &verifier, const void *obj, CommandUnion type);
bool VerifyCommandUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum SubscriptionType : int8_t {
  SubscriptionType_None = 0,
  SubscriptionType_Generic = 1,
  SubscriptionType_Robot = 2,
  SubscriptionType_Headset = 3,
  SubscriptionType_Presenter = 4,
  SubscriptionType_Geometry = 5,
  SubscriptionType_Observer = 6,
  SubscriptionType_Own = 7,
  SubscriptionType_MIN = SubscriptionType_None,
  SubscriptionType_MAX = SubscriptionType_Own
};

inline const SubscriptionType (&EnumValuesSubscriptionType())[8] {
  static const SubscriptionType values[] = {
    SubscriptionType_None,
    SubscriptionType_Generic,
    SubscriptionType_Robot,
    SubscriptionType_Headset,
    SubscriptionType_Presenter,
    SubscriptionType_Geometry,
    SubscriptionType_Observer,
    SubscriptionType_Own
  };
  return values;
}

inline const char * const *EnumNamesSubscriptionType() {
  static const char * const names[9] = {
    "None",
    "Generic",
    "Robot",
    "Headset",
    "Presenter",
    "Geometry",
    "Observer",
    "Own",
    nullptr
  };
  return names;
}

inline const char *EnumNameSubscriptionType(SubscriptionType e) {
  if (::flatbuffers::IsOutRange(e, SubscriptionType_None, SubscriptionType_Own)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSubscriptionType()[index];
}

enum EntityUnion : uint8_t {
  EntityUnion_NONE = 0,
  EntityUnion_Generic = 1,
  EntityUnion_Robot = 2,
  EntityUnion_Headset = 3,
  EntityUnion_Presenter = 4,
  EntityUnion_Geometry = 5,
  EntityUnion_Observer = 6,
  EntityUnion_Command = 7,
  EntityUnion_Node = 8,
  EntityUnion_MIN = EntityUnion_NONE,
  EntityUnion_MAX = EntityUnion_Node
};

inline const EntityUnion (&EnumValuesEntityUnion())[9] {
  static const EntityUnion values[] = {
    EntityUnion_NONE,
    EntityUnion_Generic,
    EntityUnion_Robot,
    EntityUnion_Headset,
    EntityUnion_Presenter,
    EntityUnion_Geometry,
    EntityUnion_Observer,
    EntityUnion_Command,
    EntityUnion_Node
  };
  return values;
}

inline const char * const *EnumNamesEntityUnion() {
  static const char * const names[10] = {
    "NONE",
    "Generic",
    "Robot",
    "Headset",
    "Presenter",
    "Geometry",
    "Observer",
    "Command",
    "Node",
    nullptr
  };
  return names;
}

inline const char *EnumNameEntityUnion(EntityUnion e) {
  if (::flatbuffers::IsOutRange(e, EntityUnion_NONE, EntityUnion_Node)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEntityUnion()[index];
}

template<typename T> struct EntityUnionTraits {
  static const EntityUnion enum_value = EntityUnion_NONE;
};

template<> struct EntityUnionTraits<HIVE::Commons::Flatbuffers::Generated::Generic> {
  static const EntityUnion enum_value = EntityUnion_Generic;
};

template<> struct EntityUnionTraits<HIVE::Commons::Flatbuffers::Generated::Robot> {
  static const EntityUnion enum_value = EntityUnion_Robot;
};

template<> struct EntityUnionTraits<HIVE::Commons::Flatbuffers::Generated::Headset> {
  static const EntityUnion enum_value = EntityUnion_Headset;
};

template<> struct EntityUnionTraits<HIVE::Commons::Flatbuffers::Generated::Presenter> {
  static const EntityUnion enum_value = EntityUnion_Presenter;
};

template<> struct EntityUnionTraits<HIVE::Commons::Flatbuffers::Generated::Geometry> {
  static const EntityUnion enum_value = EntityUnion_Geometry;
};

template<> struct EntityUnionTraits<HIVE::Commons::Flatbuffers::Generated::Observer> {
  static const EntityUnion enum_value = EntityUnion_Observer;
};

template<> struct EntityUnionTraits<HIVE::Commons::Flatbuffers::Generated::Command> {
  static const EntityUnion enum_value = EntityUnion_Command;
};

template<> struct EntityUnionTraits<HIVE::Commons::Flatbuffers::Generated::Node> {
  static const EntityUnion enum_value = EntityUnion_Node;
};

template<typename T> struct EntityUnionUnionTraits {
  static const EntityUnion enum_value = EntityUnion_NONE;
};

template<> struct EntityUnionUnionTraits<HIVE::Commons::Flatbuffers::Generated::GenericT> {
  static const EntityUnion enum_value = EntityUnion_Generic;
};

template<> struct EntityUnionUnionTraits<HIVE::Commons::Flatbuffers::Generated::RobotT> {
  static const EntityUnion enum_value = EntityUnion_Robot;
};

template<> struct EntityUnionUnionTraits<HIVE::Commons::Flatbuffers::Generated::HeadsetT> {
  static const EntityUnion enum_value = EntityUnion_Headset;
};

template<> struct EntityUnionUnionTraits<HIVE::Commons::Flatbuffers::Generated::PresenterT> {
  static const EntityUnion enum_value = EntityUnion_Presenter;
};

template<> struct EntityUnionUnionTraits<HIVE::Commons::Flatbuffers::Generated::GeometryT> {
  static const EntityUnion enum_value = EntityUnion_Geometry;
};

template<> struct EntityUnionUnionTraits<HIVE::Commons::Flatbuffers::Generated::ObserverT> {
  static const EntityUnion enum_value = EntityUnion_Observer;
};

template<> struct EntityUnionUnionTraits<HIVE::Commons::Flatbuffers::Generated::CommandT> {
  static const EntityUnion enum_value = EntityUnion_Command;
};

template<> struct EntityUnionUnionTraits<HIVE::Commons::Flatbuffers::Generated::NodeT> {
  static const EntityUnion enum_value = EntityUnion_Node;
};

struct EntityUnionUnion {
  EntityUnion type;
  void *value;

  EntityUnionUnion() : type(EntityUnion_NONE), value(nullptr) {}
  EntityUnionUnion(EntityUnionUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(EntityUnion_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  EntityUnionUnion(const EntityUnionUnion &);
  EntityUnionUnion &operator=(const EntityUnionUnion &u)
    { EntityUnionUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  EntityUnionUnion &operator=(EntityUnionUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~EntityUnionUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = EntityUnionUnionTraits<RT>::enum_value;
    if (type != EntityUnion_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, EntityUnion type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  HIVE::Commons::Flatbuffers::Generated::GenericT *AsGeneric() {
    return type == EntityUnion_Generic ?
      reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::GenericT *>(value) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::GenericT *AsGeneric() const {
    return type == EntityUnion_Generic ?
      reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::GenericT *>(value) : nullptr;
  }
  HIVE::Commons::Flatbuffers::Generated::RobotT *AsRobot() {
    return type == EntityUnion_Robot ?
      reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::RobotT *>(value) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::RobotT *AsRobot() const {
    return type == EntityUnion_Robot ?
      reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::RobotT *>(value) : nullptr;
  }
  HIVE::Commons::Flatbuffers::Generated::HeadsetT *AsHeadset() {
    return type == EntityUnion_Headset ?
      reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::HeadsetT *>(value) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::HeadsetT *AsHeadset() const {
    return type == EntityUnion_Headset ?
      reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::HeadsetT *>(value) : nullptr;
  }
  HIVE::Commons::Flatbuffers::Generated::PresenterT *AsPresenter() {
    return type == EntityUnion_Presenter ?
      reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::PresenterT *>(value) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::PresenterT *AsPresenter() const {
    return type == EntityUnion_Presenter ?
      reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::PresenterT *>(value) : nullptr;
  }
  HIVE::Commons::Flatbuffers::Generated::GeometryT *AsGeometry() {
    return type == EntityUnion_Geometry ?
      reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::GeometryT *>(value) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::GeometryT *AsGeometry() const {
    return type == EntityUnion_Geometry ?
      reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::GeometryT *>(value) : nullptr;
  }
  HIVE::Commons::Flatbuffers::Generated::ObserverT *AsObserver() {
    return type == EntityUnion_Observer ?
      reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::ObserverT *>(value) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::ObserverT *AsObserver() const {
    return type == EntityUnion_Observer ?
      reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::ObserverT *>(value) : nullptr;
  }
  HIVE::Commons::Flatbuffers::Generated::CommandT *AsCommand() {
    return type == EntityUnion_Command ?
      reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::CommandT *>(value) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::CommandT *AsCommand() const {
    return type == EntityUnion_Command ?
      reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::CommandT *>(value) : nullptr;
  }
  HIVE::Commons::Flatbuffers::Generated::NodeT *AsNode() {
    return type == EntityUnion_Node ?
      reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::NodeT *>(value) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::NodeT *AsNode() const {
    return type == EntityUnion_Node ?
      reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::NodeT *>(value) : nullptr;
  }
};

bool VerifyEntityUnion(::flatbuffers::Verifier &verifier, const void *obj, EntityUnion type);
bool VerifyEntityUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3(float _x, float _y, float _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    ::flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    ::flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    ::flatbuffers::WriteScalar(&z_, _z);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float w_;
  float x_;
  float y_;
  float z_;

 public:
  Vec4()
      : w_(0),
        x_(0),
        y_(0),
        z_(0) {
  }
  Vec4(float _w, float _x, float _y, float _z)
      : w_(::flatbuffers::EndianScalar(_w)),
        x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  float w() const {
    return ::flatbuffers::EndianScalar(w_);
  }
  void mutate_w(float _w) {
    ::flatbuffers::WriteScalar(&w_, _w);
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    ::flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    ::flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    ::flatbuffers::WriteScalar(&z_, _z);
  }
};
FLATBUFFERS_STRUCT_END(Vec4, 16);

struct BoundingBoxT : public ::flatbuffers::NativeTable {
  typedef BoundingBox TableType;
  std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::Vec3> centre{};
  std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::Vec3> dimensions{};
  std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::Vec4> rotation{};
  bool ellipsoid = false;
  BoundingBoxT() = default;
  BoundingBoxT(const BoundingBoxT &o);
  BoundingBoxT(BoundingBoxT&&) FLATBUFFERS_NOEXCEPT = default;
  BoundingBoxT &operator=(BoundingBoxT o) FLATBUFFERS_NOEXCEPT;
};

struct BoundingBox FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoundingBoxT NativeTableType;
  typedef BoundingBoxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTRE = 4,
    VT_DIMENSIONS = 6,
    VT_ROTATION = 8,
    VT_ELLIPSOID = 10
  };
  const HIVE::Commons::Flatbuffers::Generated::Vec3 *centre() const {
    return GetStruct<const HIVE::Commons::Flatbuffers::Generated::Vec3 *>(VT_CENTRE);
  }
  HIVE::Commons::Flatbuffers::Generated::Vec3 *mutable_centre() {
    return GetStruct<HIVE::Commons::Flatbuffers::Generated::Vec3 *>(VT_CENTRE);
  }
  const HIVE::Commons::Flatbuffers::Generated::Vec3 *dimensions() const {
    return GetStruct<const HIVE::Commons::Flatbuffers::Generated::Vec3 *>(VT_DIMENSIONS);
  }
  HIVE::Commons::Flatbuffers::Generated::Vec3 *mutable_dimensions() {
    return GetStruct<HIVE::Commons::Flatbuffers::Generated::Vec3 *>(VT_DIMENSIONS);
  }
  const HIVE::Commons::Flatbuffers::Generated::Vec4 *rotation() const {
    return GetStruct<const HIVE::Commons::Flatbuffers::Generated::Vec4 *>(VT_ROTATION);
  }
  HIVE::Commons::Flatbuffers::Generated::Vec4 *mutable_rotation() {
    return GetStruct<HIVE::Commons::Flatbuffers::Generated::Vec4 *>(VT_ROTATION);
  }
  bool ellipsoid() const {
    return GetField<uint8_t>(VT_ELLIPSOID, 0) != 0;
  }
  bool mutate_ellipsoid(bool _ellipsoid = 0) {
    return SetField<uint8_t>(VT_ELLIPSOID, static_cast<uint8_t>(_ellipsoid), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<HIVE::Commons::Flatbuffers::Generated::Vec3>(verifier, VT_CENTRE, 4) &&
           VerifyField<HIVE::Commons::Flatbuffers::Generated::Vec3>(verifier, VT_DIMENSIONS, 4) &&
           VerifyField<HIVE::Commons::Flatbuffers::Generated::Vec4>(verifier, VT_ROTATION, 4) &&
           VerifyField<uint8_t>(verifier, VT_ELLIPSOID, 1) &&
           verifier.EndTable();
  }
  BoundingBoxT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BoundingBoxT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BoundingBox> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BoundingBoxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BoundingBoxBuilder {
  typedef BoundingBox Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_centre(const HIVE::Commons::Flatbuffers::Generated::Vec3 *centre) {
    fbb_.AddStruct(BoundingBox::VT_CENTRE, centre);
  }
  void add_dimensions(const HIVE::Commons::Flatbuffers::Generated::Vec3 *dimensions) {
    fbb_.AddStruct(BoundingBox::VT_DIMENSIONS, dimensions);
  }
  void add_rotation(const HIVE::Commons::Flatbuffers::Generated::Vec4 *rotation) {
    fbb_.AddStruct(BoundingBox::VT_ROTATION, rotation);
  }
  void add_ellipsoid(bool ellipsoid) {
    fbb_.AddElement<uint8_t>(BoundingBox::VT_ELLIPSOID, static_cast<uint8_t>(ellipsoid), 0);
  }
  explicit BoundingBoxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BoundingBox> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BoundingBox>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BoundingBox> CreateBoundingBox(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const HIVE::Commons::Flatbuffers::Generated::Vec3 *centre = nullptr,
    const HIVE::Commons::Flatbuffers::Generated::Vec3 *dimensions = nullptr,
    const HIVE::Commons::Flatbuffers::Generated::Vec4 *rotation = nullptr,
    bool ellipsoid = false) {
  BoundingBoxBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_dimensions(dimensions);
  builder_.add_centre(centre);
  builder_.add_ellipsoid(ellipsoid);
  return builder_.Finish();
}

::flatbuffers::Offset<BoundingBox> CreateBoundingBox(::flatbuffers::FlatBufferBuilder &_fbb, const BoundingBoxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NodeT : public ::flatbuffers::NativeTable {
  typedef Node TableType;
  uint64_t id = 0;
  std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::Vec3> position{};
  std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::Vec4> rotation{};
  std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::Vec3> velocity{};
  float error = 0.0f;
  NodeT() = default;
  NodeT(const NodeT &o);
  NodeT(NodeT&&) FLATBUFFERS_NOEXCEPT = default;
  NodeT &operator=(NodeT o) FLATBUFFERS_NOEXCEPT;
};

struct Node FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NodeT NativeTableType;
  typedef NodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_POSITION = 6,
    VT_ROTATION = 8,
    VT_VELOCITY = 10,
    VT_ERROR = 12
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool mutate_id(uint64_t _id = 0) {
    return SetField<uint64_t>(VT_ID, _id, 0);
  }
  const HIVE::Commons::Flatbuffers::Generated::Vec3 *position() const {
    return GetStruct<const HIVE::Commons::Flatbuffers::Generated::Vec3 *>(VT_POSITION);
  }
  HIVE::Commons::Flatbuffers::Generated::Vec3 *mutable_position() {
    return GetStruct<HIVE::Commons::Flatbuffers::Generated::Vec3 *>(VT_POSITION);
  }
  const HIVE::Commons::Flatbuffers::Generated::Vec4 *rotation() const {
    return GetStruct<const HIVE::Commons::Flatbuffers::Generated::Vec4 *>(VT_ROTATION);
  }
  HIVE::Commons::Flatbuffers::Generated::Vec4 *mutable_rotation() {
    return GetStruct<HIVE::Commons::Flatbuffers::Generated::Vec4 *>(VT_ROTATION);
  }
  const HIVE::Commons::Flatbuffers::Generated::Vec3 *velocity() const {
    return GetStruct<const HIVE::Commons::Flatbuffers::Generated::Vec3 *>(VT_VELOCITY);
  }
  HIVE::Commons::Flatbuffers::Generated::Vec3 *mutable_velocity() {
    return GetStruct<HIVE::Commons::Flatbuffers::Generated::Vec3 *>(VT_VELOCITY);
  }
  float error() const {
    return GetField<float>(VT_ERROR, 0.0f);
  }
  bool mutate_error(float _error = 0.0f) {
    return SetField<float>(VT_ERROR, _error, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyField<HIVE::Commons::Flatbuffers::Generated::Vec3>(verifier, VT_POSITION, 4) &&
           VerifyField<HIVE::Commons::Flatbuffers::Generated::Vec4>(verifier, VT_ROTATION, 4) &&
           VerifyField<HIVE::Commons::Flatbuffers::Generated::Vec3>(verifier, VT_VELOCITY, 4) &&
           VerifyField<float>(verifier, VT_ERROR, 4) &&
           verifier.EndTable();
  }
  NodeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NodeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Node> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NodeBuilder {
  typedef Node Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Node::VT_ID, id, 0);
  }
  void add_position(const HIVE::Commons::Flatbuffers::Generated::Vec3 *position) {
    fbb_.AddStruct(Node::VT_POSITION, position);
  }
  void add_rotation(const HIVE::Commons::Flatbuffers::Generated::Vec4 *rotation) {
    fbb_.AddStruct(Node::VT_ROTATION, rotation);
  }
  void add_velocity(const HIVE::Commons::Flatbuffers::Generated::Vec3 *velocity) {
    fbb_.AddStruct(Node::VT_VELOCITY, velocity);
  }
  void add_error(float error) {
    fbb_.AddElement<float>(Node::VT_ERROR, error, 0.0f);
  }
  explicit NodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Node>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Node> CreateNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    const HIVE::Commons::Flatbuffers::Generated::Vec3 *position = nullptr,
    const HIVE::Commons::Flatbuffers::Generated::Vec4 *rotation = nullptr,
    const HIVE::Commons::Flatbuffers::Generated::Vec3 *velocity = nullptr,
    float error = 0.0f) {
  NodeBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_error(error);
  builder_.add_velocity(velocity);
  builder_.add_rotation(rotation);
  builder_.add_position(position);
  return builder_.Finish();
}

::flatbuffers::Offset<Node> CreateNode(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GenericT : public ::flatbuffers::NativeTable {
  typedef Generic TableType;
  uint64_t id = 0;
  std::string name{};
  uint16_t subscription = 0;
  HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate = HIVE::Commons::Flatbuffers::Generated::SubscriptionRate_None;
  std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::BoundingBoxT> bounding_box{};
  GenericT() = default;
  GenericT(const GenericT &o);
  GenericT(GenericT&&) FLATBUFFERS_NOEXCEPT = default;
  GenericT &operator=(GenericT o) FLATBUFFERS_NOEXCEPT;
};

struct Generic FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GenericT NativeTableType;
  typedef GenericBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_SUBSCRIPTION = 8,
    VT_RATE = 10,
    VT_BOUNDING_BOX = 12
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool mutate_id(uint64_t _id = 0) {
    return SetField<uint64_t>(VT_ID, _id, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  uint16_t subscription() const {
    return GetField<uint16_t>(VT_SUBSCRIPTION, 0);
  }
  bool mutate_subscription(uint16_t _subscription = 0) {
    return SetField<uint16_t>(VT_SUBSCRIPTION, _subscription, 0);
  }
  HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate() const {
    return static_cast<HIVE::Commons::Flatbuffers::Generated::SubscriptionRate>(GetField<int8_t>(VT_RATE, 0));
  }
  bool mutate_rate(HIVE::Commons::Flatbuffers::Generated::SubscriptionRate _rate = static_cast<HIVE::Commons::Flatbuffers::Generated::SubscriptionRate>(0)) {
    return SetField<int8_t>(VT_RATE, static_cast<int8_t>(_rate), 0);
  }
  const HIVE::Commons::Flatbuffers::Generated::BoundingBox *bounding_box() const {
    return GetPointer<const HIVE::Commons::Flatbuffers::Generated::BoundingBox *>(VT_BOUNDING_BOX);
  }
  HIVE::Commons::Flatbuffers::Generated::BoundingBox *mutable_bounding_box() {
    return GetPointer<HIVE::Commons::Flatbuffers::Generated::BoundingBox *>(VT_BOUNDING_BOX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint16_t>(verifier, VT_SUBSCRIPTION, 2) &&
           VerifyField<int8_t>(verifier, VT_RATE, 1) &&
           VerifyOffset(verifier, VT_BOUNDING_BOX) &&
           verifier.VerifyTable(bounding_box()) &&
           verifier.EndTable();
  }
  GenericT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GenericT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Generic> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GenericT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GenericBuilder {
  typedef Generic Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Generic::VT_ID, id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Generic::VT_NAME, name);
  }
  void add_subscription(uint16_t subscription) {
    fbb_.AddElement<uint16_t>(Generic::VT_SUBSCRIPTION, subscription, 0);
  }
  void add_rate(HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate) {
    fbb_.AddElement<int8_t>(Generic::VT_RATE, static_cast<int8_t>(rate), 0);
  }
  void add_bounding_box(::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::BoundingBox> bounding_box) {
    fbb_.AddOffset(Generic::VT_BOUNDING_BOX, bounding_box);
  }
  explicit GenericBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Generic> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Generic>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Generic> CreateGeneric(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint16_t subscription = 0,
    HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate = HIVE::Commons::Flatbuffers::Generated::SubscriptionRate_None,
    ::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::BoundingBox> bounding_box = 0) {
  GenericBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_bounding_box(bounding_box);
  builder_.add_name(name);
  builder_.add_subscription(subscription);
  builder_.add_rate(rate);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Generic> CreateGenericDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    const char *name = nullptr,
    uint16_t subscription = 0,
    HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate = HIVE::Commons::Flatbuffers::Generated::SubscriptionRate_None,
    ::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::BoundingBox> bounding_box = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return HIVE::Commons::Flatbuffers::Generated::CreateGeneric(
      _fbb,
      id,
      name__,
      subscription,
      rate,
      bounding_box);
}

::flatbuffers::Offset<Generic> CreateGeneric(::flatbuffers::FlatBufferBuilder &_fbb, const GenericT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RobotT : public ::flatbuffers::NativeTable {
  typedef Robot TableType;
  uint64_t id = 0;
  std::string name{};
  uint16_t subscription = 0;
  HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate = HIVE::Commons::Flatbuffers::Generated::SubscriptionRate_None;
  std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::BoundingBoxT> bounding_box{};
  uint32_t colour = 0;
  RobotT() = default;
  RobotT(const RobotT &o);
  RobotT(RobotT&&) FLATBUFFERS_NOEXCEPT = default;
  RobotT &operator=(RobotT o) FLATBUFFERS_NOEXCEPT;
};

struct Robot FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RobotT NativeTableType;
  typedef RobotBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_SUBSCRIPTION = 8,
    VT_RATE = 10,
    VT_BOUNDING_BOX = 12,
    VT_COLOUR = 14
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool mutate_id(uint64_t _id = 0) {
    return SetField<uint64_t>(VT_ID, _id, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  uint16_t subscription() const {
    return GetField<uint16_t>(VT_SUBSCRIPTION, 0);
  }
  bool mutate_subscription(uint16_t _subscription = 0) {
    return SetField<uint16_t>(VT_SUBSCRIPTION, _subscription, 0);
  }
  HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate() const {
    return static_cast<HIVE::Commons::Flatbuffers::Generated::SubscriptionRate>(GetField<int8_t>(VT_RATE, 0));
  }
  bool mutate_rate(HIVE::Commons::Flatbuffers::Generated::SubscriptionRate _rate = static_cast<HIVE::Commons::Flatbuffers::Generated::SubscriptionRate>(0)) {
    return SetField<int8_t>(VT_RATE, static_cast<int8_t>(_rate), 0);
  }
  const HIVE::Commons::Flatbuffers::Generated::BoundingBox *bounding_box() const {
    return GetPointer<const HIVE::Commons::Flatbuffers::Generated::BoundingBox *>(VT_BOUNDING_BOX);
  }
  HIVE::Commons::Flatbuffers::Generated::BoundingBox *mutable_bounding_box() {
    return GetPointer<HIVE::Commons::Flatbuffers::Generated::BoundingBox *>(VT_BOUNDING_BOX);
  }
  uint32_t colour() const {
    return GetField<uint32_t>(VT_COLOUR, 0);
  }
  bool mutate_colour(uint32_t _colour = 0) {
    return SetField<uint32_t>(VT_COLOUR, _colour, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint16_t>(verifier, VT_SUBSCRIPTION, 2) &&
           VerifyField<int8_t>(verifier, VT_RATE, 1) &&
           VerifyOffset(verifier, VT_BOUNDING_BOX) &&
           verifier.VerifyTable(bounding_box()) &&
           VerifyField<uint32_t>(verifier, VT_COLOUR, 4) &&
           verifier.EndTable();
  }
  RobotT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RobotT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Robot> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RobotT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RobotBuilder {
  typedef Robot Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Robot::VT_ID, id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Robot::VT_NAME, name);
  }
  void add_subscription(uint16_t subscription) {
    fbb_.AddElement<uint16_t>(Robot::VT_SUBSCRIPTION, subscription, 0);
  }
  void add_rate(HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate) {
    fbb_.AddElement<int8_t>(Robot::VT_RATE, static_cast<int8_t>(rate), 0);
  }
  void add_bounding_box(::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::BoundingBox> bounding_box) {
    fbb_.AddOffset(Robot::VT_BOUNDING_BOX, bounding_box);
  }
  void add_colour(uint32_t colour) {
    fbb_.AddElement<uint32_t>(Robot::VT_COLOUR, colour, 0);
  }
  explicit RobotBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Robot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Robot>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Robot> CreateRobot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint16_t subscription = 0,
    HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate = HIVE::Commons::Flatbuffers::Generated::SubscriptionRate_None,
    ::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::BoundingBox> bounding_box = 0,
    uint32_t colour = 0) {
  RobotBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_colour(colour);
  builder_.add_bounding_box(bounding_box);
  builder_.add_name(name);
  builder_.add_subscription(subscription);
  builder_.add_rate(rate);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Robot> CreateRobotDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    const char *name = nullptr,
    uint16_t subscription = 0,
    HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate = HIVE::Commons::Flatbuffers::Generated::SubscriptionRate_None,
    ::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::BoundingBox> bounding_box = 0,
    uint32_t colour = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return HIVE::Commons::Flatbuffers::Generated::CreateRobot(
      _fbb,
      id,
      name__,
      subscription,
      rate,
      bounding_box,
      colour);
}

::flatbuffers::Offset<Robot> CreateRobot(::flatbuffers::FlatBufferBuilder &_fbb, const RobotT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HeadsetT : public ::flatbuffers::NativeTable {
  typedef Headset TableType;
  uint64_t id = 0;
  std::string name{};
  uint16_t subscription = 0;
  HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate = HIVE::Commons::Flatbuffers::Generated::SubscriptionRate_None;
  std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::BoundingBoxT> bounding_box{};
  HeadsetT() = default;
  HeadsetT(const HeadsetT &o);
  HeadsetT(HeadsetT&&) FLATBUFFERS_NOEXCEPT = default;
  HeadsetT &operator=(HeadsetT o) FLATBUFFERS_NOEXCEPT;
};

struct Headset FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HeadsetT NativeTableType;
  typedef HeadsetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_SUBSCRIPTION = 8,
    VT_RATE = 10,
    VT_BOUNDING_BOX = 12
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool mutate_id(uint64_t _id = 0) {
    return SetField<uint64_t>(VT_ID, _id, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  uint16_t subscription() const {
    return GetField<uint16_t>(VT_SUBSCRIPTION, 0);
  }
  bool mutate_subscription(uint16_t _subscription = 0) {
    return SetField<uint16_t>(VT_SUBSCRIPTION, _subscription, 0);
  }
  HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate() const {
    return static_cast<HIVE::Commons::Flatbuffers::Generated::SubscriptionRate>(GetField<int8_t>(VT_RATE, 0));
  }
  bool mutate_rate(HIVE::Commons::Flatbuffers::Generated::SubscriptionRate _rate = static_cast<HIVE::Commons::Flatbuffers::Generated::SubscriptionRate>(0)) {
    return SetField<int8_t>(VT_RATE, static_cast<int8_t>(_rate), 0);
  }
  const HIVE::Commons::Flatbuffers::Generated::BoundingBox *bounding_box() const {
    return GetPointer<const HIVE::Commons::Flatbuffers::Generated::BoundingBox *>(VT_BOUNDING_BOX);
  }
  HIVE::Commons::Flatbuffers::Generated::BoundingBox *mutable_bounding_box() {
    return GetPointer<HIVE::Commons::Flatbuffers::Generated::BoundingBox *>(VT_BOUNDING_BOX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint16_t>(verifier, VT_SUBSCRIPTION, 2) &&
           VerifyField<int8_t>(verifier, VT_RATE, 1) &&
           VerifyOffset(verifier, VT_BOUNDING_BOX) &&
           verifier.VerifyTable(bounding_box()) &&
           verifier.EndTable();
  }
  HeadsetT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HeadsetT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Headset> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HeadsetT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HeadsetBuilder {
  typedef Headset Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Headset::VT_ID, id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Headset::VT_NAME, name);
  }
  void add_subscription(uint16_t subscription) {
    fbb_.AddElement<uint16_t>(Headset::VT_SUBSCRIPTION, subscription, 0);
  }
  void add_rate(HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate) {
    fbb_.AddElement<int8_t>(Headset::VT_RATE, static_cast<int8_t>(rate), 0);
  }
  void add_bounding_box(::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::BoundingBox> bounding_box) {
    fbb_.AddOffset(Headset::VT_BOUNDING_BOX, bounding_box);
  }
  explicit HeadsetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Headset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Headset>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Headset> CreateHeadset(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint16_t subscription = 0,
    HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate = HIVE::Commons::Flatbuffers::Generated::SubscriptionRate_None,
    ::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::BoundingBox> bounding_box = 0) {
  HeadsetBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_bounding_box(bounding_box);
  builder_.add_name(name);
  builder_.add_subscription(subscription);
  builder_.add_rate(rate);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Headset> CreateHeadsetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    const char *name = nullptr,
    uint16_t subscription = 0,
    HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate = HIVE::Commons::Flatbuffers::Generated::SubscriptionRate_None,
    ::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::BoundingBox> bounding_box = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return HIVE::Commons::Flatbuffers::Generated::CreateHeadset(
      _fbb,
      id,
      name__,
      subscription,
      rate,
      bounding_box);
}

::flatbuffers::Offset<Headset> CreateHeadset(::flatbuffers::FlatBufferBuilder &_fbb, const HeadsetT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PresenterT : public ::flatbuffers::NativeTable {
  typedef Presenter TableType;
  uint64_t id = 0;
  std::string name{};
  uint16_t subscription = 0;
  HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate = HIVE::Commons::Flatbuffers::Generated::SubscriptionRate_None;
};

struct Presenter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PresenterT NativeTableType;
  typedef PresenterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_SUBSCRIPTION = 8,
    VT_RATE = 10
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool mutate_id(uint64_t _id = 0) {
    return SetField<uint64_t>(VT_ID, _id, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  uint16_t subscription() const {
    return GetField<uint16_t>(VT_SUBSCRIPTION, 0);
  }
  bool mutate_subscription(uint16_t _subscription = 0) {
    return SetField<uint16_t>(VT_SUBSCRIPTION, _subscription, 0);
  }
  HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate() const {
    return static_cast<HIVE::Commons::Flatbuffers::Generated::SubscriptionRate>(GetField<int8_t>(VT_RATE, 0));
  }
  bool mutate_rate(HIVE::Commons::Flatbuffers::Generated::SubscriptionRate _rate = static_cast<HIVE::Commons::Flatbuffers::Generated::SubscriptionRate>(0)) {
    return SetField<int8_t>(VT_RATE, static_cast<int8_t>(_rate), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint16_t>(verifier, VT_SUBSCRIPTION, 2) &&
           VerifyField<int8_t>(verifier, VT_RATE, 1) &&
           verifier.EndTable();
  }
  PresenterT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PresenterT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Presenter> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PresenterT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PresenterBuilder {
  typedef Presenter Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Presenter::VT_ID, id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Presenter::VT_NAME, name);
  }
  void add_subscription(uint16_t subscription) {
    fbb_.AddElement<uint16_t>(Presenter::VT_SUBSCRIPTION, subscription, 0);
  }
  void add_rate(HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate) {
    fbb_.AddElement<int8_t>(Presenter::VT_RATE, static_cast<int8_t>(rate), 0);
  }
  explicit PresenterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Presenter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Presenter>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Presenter> CreatePresenter(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint16_t subscription = 0,
    HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate = HIVE::Commons::Flatbuffers::Generated::SubscriptionRate_None) {
  PresenterBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_name(name);
  builder_.add_subscription(subscription);
  builder_.add_rate(rate);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Presenter> CreatePresenterDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    const char *name = nullptr,
    uint16_t subscription = 0,
    HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate = HIVE::Commons::Flatbuffers::Generated::SubscriptionRate_None) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return HIVE::Commons::Flatbuffers::Generated::CreatePresenter(
      _fbb,
      id,
      name__,
      subscription,
      rate);
}

::flatbuffers::Offset<Presenter> CreatePresenter(::flatbuffers::FlatBufferBuilder &_fbb, const PresenterT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GeometryT : public ::flatbuffers::NativeTable {
  typedef Geometry TableType;
  uint64_t id = 0;
  std::string name{};
  uint64_t owner_id = 0;
  bool exclusive = false;
  std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::BoundingBoxT> bounding_box{};
  GeometryT() = default;
  GeometryT(const GeometryT &o);
  GeometryT(GeometryT&&) FLATBUFFERS_NOEXCEPT = default;
  GeometryT &operator=(GeometryT o) FLATBUFFERS_NOEXCEPT;
};

struct Geometry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GeometryT NativeTableType;
  typedef GeometryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_OWNER_ID = 8,
    VT_EXCLUSIVE = 10,
    VT_BOUNDING_BOX = 12
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool mutate_id(uint64_t _id = 0) {
    return SetField<uint64_t>(VT_ID, _id, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  uint64_t owner_id() const {
    return GetField<uint64_t>(VT_OWNER_ID, 0);
  }
  bool mutate_owner_id(uint64_t _owner_id = 0) {
    return SetField<uint64_t>(VT_OWNER_ID, _owner_id, 0);
  }
  bool exclusive() const {
    return GetField<uint8_t>(VT_EXCLUSIVE, 0) != 0;
  }
  bool mutate_exclusive(bool _exclusive = 0) {
    return SetField<uint8_t>(VT_EXCLUSIVE, static_cast<uint8_t>(_exclusive), 0);
  }
  const HIVE::Commons::Flatbuffers::Generated::BoundingBox *bounding_box() const {
    return GetPointer<const HIVE::Commons::Flatbuffers::Generated::BoundingBox *>(VT_BOUNDING_BOX);
  }
  HIVE::Commons::Flatbuffers::Generated::BoundingBox *mutable_bounding_box() {
    return GetPointer<HIVE::Commons::Flatbuffers::Generated::BoundingBox *>(VT_BOUNDING_BOX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint64_t>(verifier, VT_OWNER_ID, 8) &&
           VerifyField<uint8_t>(verifier, VT_EXCLUSIVE, 1) &&
           VerifyOffset(verifier, VT_BOUNDING_BOX) &&
           verifier.VerifyTable(bounding_box()) &&
           verifier.EndTable();
  }
  GeometryT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GeometryT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Geometry> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeometryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GeometryBuilder {
  typedef Geometry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Geometry::VT_ID, id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Geometry::VT_NAME, name);
  }
  void add_owner_id(uint64_t owner_id) {
    fbb_.AddElement<uint64_t>(Geometry::VT_OWNER_ID, owner_id, 0);
  }
  void add_exclusive(bool exclusive) {
    fbb_.AddElement<uint8_t>(Geometry::VT_EXCLUSIVE, static_cast<uint8_t>(exclusive), 0);
  }
  void add_bounding_box(::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::BoundingBox> bounding_box) {
    fbb_.AddOffset(Geometry::VT_BOUNDING_BOX, bounding_box);
  }
  explicit GeometryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Geometry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Geometry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Geometry> CreateGeometry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint64_t owner_id = 0,
    bool exclusive = false,
    ::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::BoundingBox> bounding_box = 0) {
  GeometryBuilder builder_(_fbb);
  builder_.add_owner_id(owner_id);
  builder_.add_id(id);
  builder_.add_bounding_box(bounding_box);
  builder_.add_name(name);
  builder_.add_exclusive(exclusive);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Geometry> CreateGeometryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    const char *name = nullptr,
    uint64_t owner_id = 0,
    bool exclusive = false,
    ::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::BoundingBox> bounding_box = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return HIVE::Commons::Flatbuffers::Generated::CreateGeometry(
      _fbb,
      id,
      name__,
      owner_id,
      exclusive,
      bounding_box);
}

::flatbuffers::Offset<Geometry> CreateGeometry(::flatbuffers::FlatBufferBuilder &_fbb, const GeometryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ObserverT : public ::flatbuffers::NativeTable {
  typedef Observer TableType;
  uint64_t id = 0;
  std::string name{};
  uint16_t subscription = 0;
  HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate = HIVE::Commons::Flatbuffers::Generated::SubscriptionRate_None;
};

struct Observer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObserverT NativeTableType;
  typedef ObserverBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_SUBSCRIPTION = 8,
    VT_RATE = 10
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool mutate_id(uint64_t _id = 0) {
    return SetField<uint64_t>(VT_ID, _id, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  uint16_t subscription() const {
    return GetField<uint16_t>(VT_SUBSCRIPTION, 0);
  }
  bool mutate_subscription(uint16_t _subscription = 0) {
    return SetField<uint16_t>(VT_SUBSCRIPTION, _subscription, 0);
  }
  HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate() const {
    return static_cast<HIVE::Commons::Flatbuffers::Generated::SubscriptionRate>(GetField<int8_t>(VT_RATE, 0));
  }
  bool mutate_rate(HIVE::Commons::Flatbuffers::Generated::SubscriptionRate _rate = static_cast<HIVE::Commons::Flatbuffers::Generated::SubscriptionRate>(0)) {
    return SetField<int8_t>(VT_RATE, static_cast<int8_t>(_rate), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint16_t>(verifier, VT_SUBSCRIPTION, 2) &&
           VerifyField<int8_t>(verifier, VT_RATE, 1) &&
           verifier.EndTable();
  }
  ObserverT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ObserverT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Observer> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ObserverT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ObserverBuilder {
  typedef Observer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Observer::VT_ID, id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Observer::VT_NAME, name);
  }
  void add_subscription(uint16_t subscription) {
    fbb_.AddElement<uint16_t>(Observer::VT_SUBSCRIPTION, subscription, 0);
  }
  void add_rate(HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate) {
    fbb_.AddElement<int8_t>(Observer::VT_RATE, static_cast<int8_t>(rate), 0);
  }
  explicit ObserverBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Observer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Observer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Observer> CreateObserver(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint16_t subscription = 0,
    HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate = HIVE::Commons::Flatbuffers::Generated::SubscriptionRate_None) {
  ObserverBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_name(name);
  builder_.add_subscription(subscription);
  builder_.add_rate(rate);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Observer> CreateObserverDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    const char *name = nullptr,
    uint16_t subscription = 0,
    HIVE::Commons::Flatbuffers::Generated::SubscriptionRate rate = HIVE::Commons::Flatbuffers::Generated::SubscriptionRate_None) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return HIVE::Commons::Flatbuffers::Generated::CreateObserver(
      _fbb,
      id,
      name__,
      subscription,
      rate);
}

::flatbuffers::Offset<Observer> CreateObserver(::flatbuffers::FlatBufferBuilder &_fbb, const ObserverT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OwnerT : public ::flatbuffers::NativeTable {
  typedef Owner TableType;
  uint64_t id = 0;
  uint16_t family = 0;
  uint64_t owner_id = 0;
  HIVE::Commons::Flatbuffers::Generated::OwnershipStatus status = HIVE::Commons::Flatbuffers::Generated::OwnershipStatus_None;
};

struct Owner FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OwnerT NativeTableType;
  typedef OwnerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_FAMILY = 6,
    VT_OWNER_ID = 8,
    VT_STATUS = 10
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool mutate_id(uint64_t _id = 0) {
    return SetField<uint64_t>(VT_ID, _id, 0);
  }
  uint16_t family() const {
    return GetField<uint16_t>(VT_FAMILY, 0);
  }
  bool mutate_family(uint16_t _family = 0) {
    return SetField<uint16_t>(VT_FAMILY, _family, 0);
  }
  uint64_t owner_id() const {
    return GetField<uint64_t>(VT_OWNER_ID, 0);
  }
  bool mutate_owner_id(uint64_t _owner_id = 0) {
    return SetField<uint64_t>(VT_OWNER_ID, _owner_id, 0);
  }
  HIVE::Commons::Flatbuffers::Generated::OwnershipStatus status() const {
    return static_cast<HIVE::Commons::Flatbuffers::Generated::OwnershipStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  bool mutate_status(HIVE::Commons::Flatbuffers::Generated::OwnershipStatus _status = static_cast<HIVE::Commons::Flatbuffers::Generated::OwnershipStatus>(0)) {
    return SetField<int8_t>(VT_STATUS, static_cast<int8_t>(_status), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyField<uint16_t>(verifier, VT_FAMILY, 2) &&
           VerifyField<uint64_t>(verifier, VT_OWNER_ID, 8) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           verifier.EndTable();
  }
  OwnerT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OwnerT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Owner> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OwnerT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OwnerBuilder {
  typedef Owner Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Owner::VT_ID, id, 0);
  }
  void add_family(uint16_t family) {
    fbb_.AddElement<uint16_t>(Owner::VT_FAMILY, family, 0);
  }
  void add_owner_id(uint64_t owner_id) {
    fbb_.AddElement<uint64_t>(Owner::VT_OWNER_ID, owner_id, 0);
  }
  void add_status(HIVE::Commons::Flatbuffers::Generated::OwnershipStatus status) {
    fbb_.AddElement<int8_t>(Owner::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  explicit OwnerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Owner> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Owner>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Owner> CreateOwner(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    uint16_t family = 0,
    uint64_t owner_id = 0,
    HIVE::Commons::Flatbuffers::Generated::OwnershipStatus status = HIVE::Commons::Flatbuffers::Generated::OwnershipStatus_None) {
  OwnerBuilder builder_(_fbb);
  builder_.add_owner_id(owner_id);
  builder_.add_id(id);
  builder_.add_family(family);
  builder_.add_status(status);
  return builder_.Finish();
}

::flatbuffers::Offset<Owner> CreateOwner(::flatbuffers::FlatBufferBuilder &_fbb, const OwnerT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MoveToT : public ::flatbuffers::NativeTable {
  typedef MoveTo TableType;
  uint64_t id = 0;
  uint16_t family = 0;
  std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::Vec3> destination{};
  MoveToT() = default;
  MoveToT(const MoveToT &o);
  MoveToT(MoveToT&&) FLATBUFFERS_NOEXCEPT = default;
  MoveToT &operator=(MoveToT o) FLATBUFFERS_NOEXCEPT;
};

struct MoveTo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MoveToT NativeTableType;
  typedef MoveToBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_FAMILY = 6,
    VT_DESTINATION = 8
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool mutate_id(uint64_t _id = 0) {
    return SetField<uint64_t>(VT_ID, _id, 0);
  }
  uint16_t family() const {
    return GetField<uint16_t>(VT_FAMILY, 0);
  }
  bool mutate_family(uint16_t _family = 0) {
    return SetField<uint16_t>(VT_FAMILY, _family, 0);
  }
  const HIVE::Commons::Flatbuffers::Generated::Vec3 *destination() const {
    return GetStruct<const HIVE::Commons::Flatbuffers::Generated::Vec3 *>(VT_DESTINATION);
  }
  HIVE::Commons::Flatbuffers::Generated::Vec3 *mutable_destination() {
    return GetStruct<HIVE::Commons::Flatbuffers::Generated::Vec3 *>(VT_DESTINATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyField<uint16_t>(verifier, VT_FAMILY, 2) &&
           VerifyField<HIVE::Commons::Flatbuffers::Generated::Vec3>(verifier, VT_DESTINATION, 4) &&
           verifier.EndTable();
  }
  MoveToT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MoveToT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MoveTo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MoveToT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MoveToBuilder {
  typedef MoveTo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(MoveTo::VT_ID, id, 0);
  }
  void add_family(uint16_t family) {
    fbb_.AddElement<uint16_t>(MoveTo::VT_FAMILY, family, 0);
  }
  void add_destination(const HIVE::Commons::Flatbuffers::Generated::Vec3 *destination) {
    fbb_.AddStruct(MoveTo::VT_DESTINATION, destination);
  }
  explicit MoveToBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MoveTo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MoveTo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MoveTo> CreateMoveTo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    uint16_t family = 0,
    const HIVE::Commons::Flatbuffers::Generated::Vec3 *destination = nullptr) {
  MoveToBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_destination(destination);
  builder_.add_family(family);
  return builder_.Finish();
}

::flatbuffers::Offset<MoveTo> CreateMoveTo(::flatbuffers::FlatBufferBuilder &_fbb, const MoveToT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SleepT : public ::flatbuffers::NativeTable {
  typedef Sleep TableType;
  uint64_t id = 0;
  uint16_t family = 0;
  float duration = 0.0f;
  bool sleep = false;
};

struct Sleep FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SleepT NativeTableType;
  typedef SleepBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_FAMILY = 6,
    VT_DURATION = 8,
    VT_SLEEP = 10
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool mutate_id(uint64_t _id = 0) {
    return SetField<uint64_t>(VT_ID, _id, 0);
  }
  uint16_t family() const {
    return GetField<uint16_t>(VT_FAMILY, 0);
  }
  bool mutate_family(uint16_t _family = 0) {
    return SetField<uint16_t>(VT_FAMILY, _family, 0);
  }
  float duration() const {
    return GetField<float>(VT_DURATION, 0.0f);
  }
  bool mutate_duration(float _duration = 0.0f) {
    return SetField<float>(VT_DURATION, _duration, 0.0f);
  }
  bool sleep() const {
    return GetField<uint8_t>(VT_SLEEP, 0) != 0;
  }
  bool mutate_sleep(bool _sleep = 0) {
    return SetField<uint8_t>(VT_SLEEP, static_cast<uint8_t>(_sleep), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyField<uint16_t>(verifier, VT_FAMILY, 2) &&
           VerifyField<float>(verifier, VT_DURATION, 4) &&
           VerifyField<uint8_t>(verifier, VT_SLEEP, 1) &&
           verifier.EndTable();
  }
  SleepT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SleepT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Sleep> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SleepT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SleepBuilder {
  typedef Sleep Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Sleep::VT_ID, id, 0);
  }
  void add_family(uint16_t family) {
    fbb_.AddElement<uint16_t>(Sleep::VT_FAMILY, family, 0);
  }
  void add_duration(float duration) {
    fbb_.AddElement<float>(Sleep::VT_DURATION, duration, 0.0f);
  }
  void add_sleep(bool sleep) {
    fbb_.AddElement<uint8_t>(Sleep::VT_SLEEP, static_cast<uint8_t>(sleep), 0);
  }
  explicit SleepBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Sleep> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Sleep>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Sleep> CreateSleep(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    uint16_t family = 0,
    float duration = 0.0f,
    bool sleep = false) {
  SleepBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_duration(duration);
  builder_.add_family(family);
  builder_.add_sleep(sleep);
  return builder_.Finish();
}

::flatbuffers::Offset<Sleep> CreateSleep(::flatbuffers::FlatBufferBuilder &_fbb, const SleepT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CommandT : public ::flatbuffers::NativeTable {
  typedef Command TableType;
  HIVE::Commons::Flatbuffers::Generated::CommandUnionUnion command{};
};

struct Command FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandT NativeTableType;
  typedef CommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND_TYPE = 4,
    VT_COMMAND = 6
  };
  HIVE::Commons::Flatbuffers::Generated::CommandUnion command_type() const {
    return static_cast<HIVE::Commons::Flatbuffers::Generated::CommandUnion>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  template<typename T> const T *command_as() const;
  const HIVE::Commons::Flatbuffers::Generated::Owner *command_as_Owner() const {
    return command_type() == HIVE::Commons::Flatbuffers::Generated::CommandUnion_Owner ? static_cast<const HIVE::Commons::Flatbuffers::Generated::Owner *>(command()) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::MoveTo *command_as_MoveTo() const {
    return command_type() == HIVE::Commons::Flatbuffers::Generated::CommandUnion_MoveTo ? static_cast<const HIVE::Commons::Flatbuffers::Generated::MoveTo *>(command()) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::Sleep *command_as_Sleep() const {
    return command_type() == HIVE::Commons::Flatbuffers::Generated::CommandUnion_Sleep ? static_cast<const HIVE::Commons::Flatbuffers::Generated::Sleep *>(command()) : nullptr;
  }
  void *mutable_command() {
    return GetPointer<void *>(VT_COMMAND);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           VerifyCommandUnion(verifier, command(), command_type()) &&
           verifier.EndTable();
  }
  CommandT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CommandT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Command> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const HIVE::Commons::Flatbuffers::Generated::Owner *Command::command_as<HIVE::Commons::Flatbuffers::Generated::Owner>() const {
  return command_as_Owner();
}

template<> inline const HIVE::Commons::Flatbuffers::Generated::MoveTo *Command::command_as<HIVE::Commons::Flatbuffers::Generated::MoveTo>() const {
  return command_as_MoveTo();
}

template<> inline const HIVE::Commons::Flatbuffers::Generated::Sleep *Command::command_as<HIVE::Commons::Flatbuffers::Generated::Sleep>() const {
  return command_as_Sleep();
}

struct CommandBuilder {
  typedef Command Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_command_type(HIVE::Commons::Flatbuffers::Generated::CommandUnion command_type) {
    fbb_.AddElement<uint8_t>(Command::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(::flatbuffers::Offset<void> command) {
    fbb_.AddOffset(Command::VT_COMMAND, command);
  }
  explicit CommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Command> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Command>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Command> CreateCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    HIVE::Commons::Flatbuffers::Generated::CommandUnion command_type = HIVE::Commons::Flatbuffers::Generated::CommandUnion_NONE,
    ::flatbuffers::Offset<void> command = 0) {
  CommandBuilder builder_(_fbb);
  builder_.add_command(command);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

::flatbuffers::Offset<Command> CreateCommand(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EntityT : public ::flatbuffers::NativeTable {
  typedef Entity TableType;
  HIVE::Commons::Flatbuffers::Generated::EntityUnionUnion entity{};
};

struct Entity FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EntityT NativeTableType;
  typedef EntityBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTITY_TYPE = 4,
    VT_ENTITY = 6
  };
  HIVE::Commons::Flatbuffers::Generated::EntityUnion entity_type() const {
    return static_cast<HIVE::Commons::Flatbuffers::Generated::EntityUnion>(GetField<uint8_t>(VT_ENTITY_TYPE, 0));
  }
  const void *entity() const {
    return GetPointer<const void *>(VT_ENTITY);
  }
  template<typename T> const T *entity_as() const;
  const HIVE::Commons::Flatbuffers::Generated::Generic *entity_as_Generic() const {
    return entity_type() == HIVE::Commons::Flatbuffers::Generated::EntityUnion_Generic ? static_cast<const HIVE::Commons::Flatbuffers::Generated::Generic *>(entity()) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::Robot *entity_as_Robot() const {
    return entity_type() == HIVE::Commons::Flatbuffers::Generated::EntityUnion_Robot ? static_cast<const HIVE::Commons::Flatbuffers::Generated::Robot *>(entity()) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::Headset *entity_as_Headset() const {
    return entity_type() == HIVE::Commons::Flatbuffers::Generated::EntityUnion_Headset ? static_cast<const HIVE::Commons::Flatbuffers::Generated::Headset *>(entity()) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::Presenter *entity_as_Presenter() const {
    return entity_type() == HIVE::Commons::Flatbuffers::Generated::EntityUnion_Presenter ? static_cast<const HIVE::Commons::Flatbuffers::Generated::Presenter *>(entity()) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::Geometry *entity_as_Geometry() const {
    return entity_type() == HIVE::Commons::Flatbuffers::Generated::EntityUnion_Geometry ? static_cast<const HIVE::Commons::Flatbuffers::Generated::Geometry *>(entity()) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::Observer *entity_as_Observer() const {
    return entity_type() == HIVE::Commons::Flatbuffers::Generated::EntityUnion_Observer ? static_cast<const HIVE::Commons::Flatbuffers::Generated::Observer *>(entity()) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::Command *entity_as_Command() const {
    return entity_type() == HIVE::Commons::Flatbuffers::Generated::EntityUnion_Command ? static_cast<const HIVE::Commons::Flatbuffers::Generated::Command *>(entity()) : nullptr;
  }
  const HIVE::Commons::Flatbuffers::Generated::Node *entity_as_Node() const {
    return entity_type() == HIVE::Commons::Flatbuffers::Generated::EntityUnion_Node ? static_cast<const HIVE::Commons::Flatbuffers::Generated::Node *>(entity()) : nullptr;
  }
  void *mutable_entity() {
    return GetPointer<void *>(VT_ENTITY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENTITY_TYPE, 1) &&
           VerifyOffset(verifier, VT_ENTITY) &&
           VerifyEntityUnion(verifier, entity(), entity_type()) &&
           verifier.EndTable();
  }
  EntityT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EntityT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Entity> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EntityT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const HIVE::Commons::Flatbuffers::Generated::Generic *Entity::entity_as<HIVE::Commons::Flatbuffers::Generated::Generic>() const {
  return entity_as_Generic();
}

template<> inline const HIVE::Commons::Flatbuffers::Generated::Robot *Entity::entity_as<HIVE::Commons::Flatbuffers::Generated::Robot>() const {
  return entity_as_Robot();
}

template<> inline const HIVE::Commons::Flatbuffers::Generated::Headset *Entity::entity_as<HIVE::Commons::Flatbuffers::Generated::Headset>() const {
  return entity_as_Headset();
}

template<> inline const HIVE::Commons::Flatbuffers::Generated::Presenter *Entity::entity_as<HIVE::Commons::Flatbuffers::Generated::Presenter>() const {
  return entity_as_Presenter();
}

template<> inline const HIVE::Commons::Flatbuffers::Generated::Geometry *Entity::entity_as<HIVE::Commons::Flatbuffers::Generated::Geometry>() const {
  return entity_as_Geometry();
}

template<> inline const HIVE::Commons::Flatbuffers::Generated::Observer *Entity::entity_as<HIVE::Commons::Flatbuffers::Generated::Observer>() const {
  return entity_as_Observer();
}

template<> inline const HIVE::Commons::Flatbuffers::Generated::Command *Entity::entity_as<HIVE::Commons::Flatbuffers::Generated::Command>() const {
  return entity_as_Command();
}

template<> inline const HIVE::Commons::Flatbuffers::Generated::Node *Entity::entity_as<HIVE::Commons::Flatbuffers::Generated::Node>() const {
  return entity_as_Node();
}

struct EntityBuilder {
  typedef Entity Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_entity_type(HIVE::Commons::Flatbuffers::Generated::EntityUnion entity_type) {
    fbb_.AddElement<uint8_t>(Entity::VT_ENTITY_TYPE, static_cast<uint8_t>(entity_type), 0);
  }
  void add_entity(::flatbuffers::Offset<void> entity) {
    fbb_.AddOffset(Entity::VT_ENTITY, entity);
  }
  explicit EntityBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Entity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Entity>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Entity> CreateEntity(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    HIVE::Commons::Flatbuffers::Generated::EntityUnion entity_type = HIVE::Commons::Flatbuffers::Generated::EntityUnion_NONE,
    ::flatbuffers::Offset<void> entity = 0) {
  EntityBuilder builder_(_fbb);
  builder_.add_entity(entity);
  builder_.add_entity_type(entity_type);
  return builder_.Finish();
}

::flatbuffers::Offset<Entity> CreateEntity(::flatbuffers::FlatBufferBuilder &_fbb, const EntityT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PayloadT : public ::flatbuffers::NativeTable {
  typedef Payload TableType;
  std::vector<uint8_t> data{};
};

struct Payload FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PayloadT NativeTableType;
  typedef PayloadBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  const HIVE::Commons::Flatbuffers::Generated::Entity *data_nested_root() const {
    const auto _f = data();
    return _f ? ::flatbuffers::GetRoot<HIVE::Commons::Flatbuffers::Generated::Entity>(_f->Data())
              : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyNestedFlatBuffer<HIVE::Commons::Flatbuffers::Generated::Entity>(data(), nullptr) &&
           verifier.EndTable();
  }
  PayloadT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PayloadT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Payload> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PayloadT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PayloadBuilder {
  typedef Payload Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Payload::VT_DATA, data);
  }
  explicit PayloadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Payload> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Payload>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Payload> CreatePayload(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  PayloadBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Payload> CreatePayloadDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return HIVE::Commons::Flatbuffers::Generated::CreatePayload(
      _fbb,
      data__);
}

::flatbuffers::Offset<Payload> CreatePayload(::flatbuffers::FlatBufferBuilder &_fbb, const PayloadT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StateT : public ::flatbuffers::NativeTable {
  typedef State TableType;
  std::vector<std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::PayloadT>> payload{};
  StateT() = default;
  StateT(const StateT &o);
  StateT(StateT&&) FLATBUFFERS_NOEXCEPT = default;
  StateT &operator=(StateT o) FLATBUFFERS_NOEXCEPT;
};

struct State FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StateT NativeTableType;
  typedef StateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAYLOAD = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::Payload>> *payload() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::Payload>> *>(VT_PAYLOAD);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::Payload>> *mutable_payload() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::Payload>> *>(VT_PAYLOAD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.VerifyVector(payload()) &&
           verifier.VerifyVectorOfTables(payload()) &&
           verifier.EndTable();
  }
  StateT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StateT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<State> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StateBuilder {
  typedef State Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_payload(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::Payload>>> payload) {
    fbb_.AddOffset(State::VT_PAYLOAD, payload);
  }
  explicit StateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<State>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<State> CreateState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::Payload>>> payload = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_payload(payload);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<State> CreateStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::Payload>> *payload = nullptr) {
  auto payload__ = payload ? _fbb.CreateVector<::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::Payload>>(*payload) : 0;
  return HIVE::Commons::Flatbuffers::Generated::CreateState(
      _fbb,
      payload__);
}

::flatbuffers::Offset<State> CreateState(::flatbuffers::FlatBufferBuilder &_fbb, const StateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline BoundingBoxT::BoundingBoxT(const BoundingBoxT &o)
      : centre((o.centre) ? new HIVE::Commons::Flatbuffers::Generated::Vec3(*o.centre) : nullptr),
        dimensions((o.dimensions) ? new HIVE::Commons::Flatbuffers::Generated::Vec3(*o.dimensions) : nullptr),
        rotation((o.rotation) ? new HIVE::Commons::Flatbuffers::Generated::Vec4(*o.rotation) : nullptr),
        ellipsoid(o.ellipsoid) {
}

inline BoundingBoxT &BoundingBoxT::operator=(BoundingBoxT o) FLATBUFFERS_NOEXCEPT {
  std::swap(centre, o.centre);
  std::swap(dimensions, o.dimensions);
  std::swap(rotation, o.rotation);
  std::swap(ellipsoid, o.ellipsoid);
  return *this;
}

inline BoundingBoxT *BoundingBox::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BoundingBoxT>(new BoundingBoxT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BoundingBox::UnPackTo(BoundingBoxT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = centre(); if (_e) _o->centre = std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::Vec3>(new HIVE::Commons::Flatbuffers::Generated::Vec3(*_e)); }
  { auto _e = dimensions(); if (_e) _o->dimensions = std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::Vec3>(new HIVE::Commons::Flatbuffers::Generated::Vec3(*_e)); }
  { auto _e = rotation(); if (_e) _o->rotation = std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::Vec4>(new HIVE::Commons::Flatbuffers::Generated::Vec4(*_e)); }
  { auto _e = ellipsoid(); _o->ellipsoid = _e; }
}

inline ::flatbuffers::Offset<BoundingBox> BoundingBox::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BoundingBoxT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBoundingBox(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BoundingBox> CreateBoundingBox(::flatbuffers::FlatBufferBuilder &_fbb, const BoundingBoxT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BoundingBoxT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _centre = _o->centre ? _o->centre.get() : nullptr;
  auto _dimensions = _o->dimensions ? _o->dimensions.get() : nullptr;
  auto _rotation = _o->rotation ? _o->rotation.get() : nullptr;
  auto _ellipsoid = _o->ellipsoid;
  return HIVE::Commons::Flatbuffers::Generated::CreateBoundingBox(
      _fbb,
      _centre,
      _dimensions,
      _rotation,
      _ellipsoid);
}

inline NodeT::NodeT(const NodeT &o)
      : id(o.id),
        position((o.position) ? new HIVE::Commons::Flatbuffers::Generated::Vec3(*o.position) : nullptr),
        rotation((o.rotation) ? new HIVE::Commons::Flatbuffers::Generated::Vec4(*o.rotation) : nullptr),
        velocity((o.velocity) ? new HIVE::Commons::Flatbuffers::Generated::Vec3(*o.velocity) : nullptr),
        error(o.error) {
}

inline NodeT &NodeT::operator=(NodeT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(position, o.position);
  std::swap(rotation, o.rotation);
  std::swap(velocity, o.velocity);
  std::swap(error, o.error);
  return *this;
}

inline NodeT *Node::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<NodeT>(new NodeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Node::UnPackTo(NodeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::Vec3>(new HIVE::Commons::Flatbuffers::Generated::Vec3(*_e)); }
  { auto _e = rotation(); if (_e) _o->rotation = std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::Vec4>(new HIVE::Commons::Flatbuffers::Generated::Vec4(*_e)); }
  { auto _e = velocity(); if (_e) _o->velocity = std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::Vec3>(new HIVE::Commons::Flatbuffers::Generated::Vec3(*_e)); }
  { auto _e = error(); _o->error = _e; }
}

inline ::flatbuffers::Offset<Node> Node::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNode(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Node> CreateNode(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NodeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _position = _o->position ? _o->position.get() : nullptr;
  auto _rotation = _o->rotation ? _o->rotation.get() : nullptr;
  auto _velocity = _o->velocity ? _o->velocity.get() : nullptr;
  auto _error = _o->error;
  return HIVE::Commons::Flatbuffers::Generated::CreateNode(
      _fbb,
      _id,
      _position,
      _rotation,
      _velocity,
      _error);
}

inline GenericT::GenericT(const GenericT &o)
      : id(o.id),
        name(o.name),
        subscription(o.subscription),
        rate(o.rate),
        bounding_box((o.bounding_box) ? new HIVE::Commons::Flatbuffers::Generated::BoundingBoxT(*o.bounding_box) : nullptr) {
}

inline GenericT &GenericT::operator=(GenericT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(name, o.name);
  std::swap(subscription, o.subscription);
  std::swap(rate, o.rate);
  std::swap(bounding_box, o.bounding_box);
  return *this;
}

inline GenericT *Generic::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GenericT>(new GenericT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Generic::UnPackTo(GenericT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = subscription(); _o->subscription = _e; }
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = bounding_box(); if (_e) { if(_o->bounding_box) { _e->UnPackTo(_o->bounding_box.get(), _resolver); } else { _o->bounding_box = std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::BoundingBoxT>(_e->UnPack(_resolver)); } } else if (_o->bounding_box) { _o->bounding_box.reset(); } }
}

inline ::flatbuffers::Offset<Generic> Generic::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GenericT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeneric(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Generic> CreateGeneric(::flatbuffers::FlatBufferBuilder &_fbb, const GenericT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GenericT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _subscription = _o->subscription;
  auto _rate = _o->rate;
  auto _bounding_box = _o->bounding_box ? CreateBoundingBox(_fbb, _o->bounding_box.get(), _rehasher) : 0;
  return HIVE::Commons::Flatbuffers::Generated::CreateGeneric(
      _fbb,
      _id,
      _name,
      _subscription,
      _rate,
      _bounding_box);
}

inline RobotT::RobotT(const RobotT &o)
      : id(o.id),
        name(o.name),
        subscription(o.subscription),
        rate(o.rate),
        bounding_box((o.bounding_box) ? new HIVE::Commons::Flatbuffers::Generated::BoundingBoxT(*o.bounding_box) : nullptr),
        colour(o.colour) {
}

inline RobotT &RobotT::operator=(RobotT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(name, o.name);
  std::swap(subscription, o.subscription);
  std::swap(rate, o.rate);
  std::swap(bounding_box, o.bounding_box);
  std::swap(colour, o.colour);
  return *this;
}

inline RobotT *Robot::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RobotT>(new RobotT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Robot::UnPackTo(RobotT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = subscription(); _o->subscription = _e; }
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = bounding_box(); if (_e) { if(_o->bounding_box) { _e->UnPackTo(_o->bounding_box.get(), _resolver); } else { _o->bounding_box = std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::BoundingBoxT>(_e->UnPack(_resolver)); } } else if (_o->bounding_box) { _o->bounding_box.reset(); } }
  { auto _e = colour(); _o->colour = _e; }
}

inline ::flatbuffers::Offset<Robot> Robot::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RobotT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRobot(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Robot> CreateRobot(::flatbuffers::FlatBufferBuilder &_fbb, const RobotT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RobotT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _subscription = _o->subscription;
  auto _rate = _o->rate;
  auto _bounding_box = _o->bounding_box ? CreateBoundingBox(_fbb, _o->bounding_box.get(), _rehasher) : 0;
  auto _colour = _o->colour;
  return HIVE::Commons::Flatbuffers::Generated::CreateRobot(
      _fbb,
      _id,
      _name,
      _subscription,
      _rate,
      _bounding_box,
      _colour);
}

inline HeadsetT::HeadsetT(const HeadsetT &o)
      : id(o.id),
        name(o.name),
        subscription(o.subscription),
        rate(o.rate),
        bounding_box((o.bounding_box) ? new HIVE::Commons::Flatbuffers::Generated::BoundingBoxT(*o.bounding_box) : nullptr) {
}

inline HeadsetT &HeadsetT::operator=(HeadsetT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(name, o.name);
  std::swap(subscription, o.subscription);
  std::swap(rate, o.rate);
  std::swap(bounding_box, o.bounding_box);
  return *this;
}

inline HeadsetT *Headset::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HeadsetT>(new HeadsetT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Headset::UnPackTo(HeadsetT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = subscription(); _o->subscription = _e; }
  { auto _e = rate(); _o->rate = _e; }
  { auto _e = bounding_box(); if (_e) { if(_o->bounding_box) { _e->UnPackTo(_o->bounding_box.get(), _resolver); } else { _o->bounding_box = std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::BoundingBoxT>(_e->UnPack(_resolver)); } } else if (_o->bounding_box) { _o->bounding_box.reset(); } }
}

inline ::flatbuffers::Offset<Headset> Headset::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HeadsetT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHeadset(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Headset> CreateHeadset(::flatbuffers::FlatBufferBuilder &_fbb, const HeadsetT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HeadsetT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _subscription = _o->subscription;
  auto _rate = _o->rate;
  auto _bounding_box = _o->bounding_box ? CreateBoundingBox(_fbb, _o->bounding_box.get(), _rehasher) : 0;
  return HIVE::Commons::Flatbuffers::Generated::CreateHeadset(
      _fbb,
      _id,
      _name,
      _subscription,
      _rate,
      _bounding_box);
}

inline PresenterT *Presenter::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PresenterT>(new PresenterT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Presenter::UnPackTo(PresenterT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = subscription(); _o->subscription = _e; }
  { auto _e = rate(); _o->rate = _e; }
}

inline ::flatbuffers::Offset<Presenter> Presenter::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PresenterT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePresenter(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Presenter> CreatePresenter(::flatbuffers::FlatBufferBuilder &_fbb, const PresenterT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PresenterT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _subscription = _o->subscription;
  auto _rate = _o->rate;
  return HIVE::Commons::Flatbuffers::Generated::CreatePresenter(
      _fbb,
      _id,
      _name,
      _subscription,
      _rate);
}

inline GeometryT::GeometryT(const GeometryT &o)
      : id(o.id),
        name(o.name),
        owner_id(o.owner_id),
        exclusive(o.exclusive),
        bounding_box((o.bounding_box) ? new HIVE::Commons::Flatbuffers::Generated::BoundingBoxT(*o.bounding_box) : nullptr) {
}

inline GeometryT &GeometryT::operator=(GeometryT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(name, o.name);
  std::swap(owner_id, o.owner_id);
  std::swap(exclusive, o.exclusive);
  std::swap(bounding_box, o.bounding_box);
  return *this;
}

inline GeometryT *Geometry::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GeometryT>(new GeometryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Geometry::UnPackTo(GeometryT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = owner_id(); _o->owner_id = _e; }
  { auto _e = exclusive(); _o->exclusive = _e; }
  { auto _e = bounding_box(); if (_e) { if(_o->bounding_box) { _e->UnPackTo(_o->bounding_box.get(), _resolver); } else { _o->bounding_box = std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::BoundingBoxT>(_e->UnPack(_resolver)); } } else if (_o->bounding_box) { _o->bounding_box.reset(); } }
}

inline ::flatbuffers::Offset<Geometry> Geometry::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GeometryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGeometry(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Geometry> CreateGeometry(::flatbuffers::FlatBufferBuilder &_fbb, const GeometryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GeometryT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _owner_id = _o->owner_id;
  auto _exclusive = _o->exclusive;
  auto _bounding_box = _o->bounding_box ? CreateBoundingBox(_fbb, _o->bounding_box.get(), _rehasher) : 0;
  return HIVE::Commons::Flatbuffers::Generated::CreateGeometry(
      _fbb,
      _id,
      _name,
      _owner_id,
      _exclusive,
      _bounding_box);
}

inline ObserverT *Observer::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ObserverT>(new ObserverT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Observer::UnPackTo(ObserverT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = subscription(); _o->subscription = _e; }
  { auto _e = rate(); _o->rate = _e; }
}

inline ::flatbuffers::Offset<Observer> Observer::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ObserverT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateObserver(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Observer> CreateObserver(::flatbuffers::FlatBufferBuilder &_fbb, const ObserverT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ObserverT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _subscription = _o->subscription;
  auto _rate = _o->rate;
  return HIVE::Commons::Flatbuffers::Generated::CreateObserver(
      _fbb,
      _id,
      _name,
      _subscription,
      _rate);
}

inline OwnerT *Owner::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OwnerT>(new OwnerT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Owner::UnPackTo(OwnerT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = family(); _o->family = _e; }
  { auto _e = owner_id(); _o->owner_id = _e; }
  { auto _e = status(); _o->status = _e; }
}

inline ::flatbuffers::Offset<Owner> Owner::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const OwnerT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOwner(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Owner> CreateOwner(::flatbuffers::FlatBufferBuilder &_fbb, const OwnerT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const OwnerT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _family = _o->family;
  auto _owner_id = _o->owner_id;
  auto _status = _o->status;
  return HIVE::Commons::Flatbuffers::Generated::CreateOwner(
      _fbb,
      _id,
      _family,
      _owner_id,
      _status);
}

inline MoveToT::MoveToT(const MoveToT &o)
      : id(o.id),
        family(o.family),
        destination((o.destination) ? new HIVE::Commons::Flatbuffers::Generated::Vec3(*o.destination) : nullptr) {
}

inline MoveToT &MoveToT::operator=(MoveToT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(family, o.family);
  std::swap(destination, o.destination);
  return *this;
}

inline MoveToT *MoveTo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MoveToT>(new MoveToT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MoveTo::UnPackTo(MoveToT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = family(); _o->family = _e; }
  { auto _e = destination(); if (_e) _o->destination = std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::Vec3>(new HIVE::Commons::Flatbuffers::Generated::Vec3(*_e)); }
}

inline ::flatbuffers::Offset<MoveTo> MoveTo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MoveToT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMoveTo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MoveTo> CreateMoveTo(::flatbuffers::FlatBufferBuilder &_fbb, const MoveToT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MoveToT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _family = _o->family;
  auto _destination = _o->destination ? _o->destination.get() : nullptr;
  return HIVE::Commons::Flatbuffers::Generated::CreateMoveTo(
      _fbb,
      _id,
      _family,
      _destination);
}

inline SleepT *Sleep::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SleepT>(new SleepT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Sleep::UnPackTo(SleepT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = family(); _o->family = _e; }
  { auto _e = duration(); _o->duration = _e; }
  { auto _e = sleep(); _o->sleep = _e; }
}

inline ::flatbuffers::Offset<Sleep> Sleep::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SleepT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSleep(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Sleep> CreateSleep(::flatbuffers::FlatBufferBuilder &_fbb, const SleepT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SleepT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _family = _o->family;
  auto _duration = _o->duration;
  auto _sleep = _o->sleep;
  return HIVE::Commons::Flatbuffers::Generated::CreateSleep(
      _fbb,
      _id,
      _family,
      _duration,
      _sleep);
}

inline CommandT *Command::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CommandT>(new CommandT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Command::UnPackTo(CommandT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = command_type(); _o->command.type = _e; }
  { auto _e = command(); if (_e) _o->command.value = HIVE::Commons::Flatbuffers::Generated::CommandUnionUnion::UnPack(_e, command_type(), _resolver); }
}

inline ::flatbuffers::Offset<Command> Command::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCommand(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Command> CreateCommand(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CommandT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _command_type = _o->command.type;
  auto _command = _o->command.Pack(_fbb);
  return HIVE::Commons::Flatbuffers::Generated::CreateCommand(
      _fbb,
      _command_type,
      _command);
}

inline EntityT *Entity::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EntityT>(new EntityT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Entity::UnPackTo(EntityT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity_type(); _o->entity.type = _e; }
  { auto _e = entity(); if (_e) _o->entity.value = HIVE::Commons::Flatbuffers::Generated::EntityUnionUnion::UnPack(_e, entity_type(), _resolver); }
}

inline ::flatbuffers::Offset<Entity> Entity::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EntityT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEntity(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Entity> CreateEntity(::flatbuffers::FlatBufferBuilder &_fbb, const EntityT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EntityT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _entity_type = _o->entity.type;
  auto _entity = _o->entity.Pack(_fbb);
  return HIVE::Commons::Flatbuffers::Generated::CreateEntity(
      _fbb,
      _entity_type,
      _entity);
}

inline PayloadT *Payload::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PayloadT>(new PayloadT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Payload::UnPackTo(PayloadT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline ::flatbuffers::Offset<Payload> Payload::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PayloadT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePayload(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Payload> CreatePayload(::flatbuffers::FlatBufferBuilder &_fbb, const PayloadT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PayloadT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return HIVE::Commons::Flatbuffers::Generated::CreatePayload(
      _fbb,
      _data);
}

inline StateT::StateT(const StateT &o) {
  payload.reserve(o.payload.size());
  for (const auto &payload_ : o.payload) { payload.emplace_back((payload_) ? new HIVE::Commons::Flatbuffers::Generated::PayloadT(*payload_) : nullptr); }
}

inline StateT &StateT::operator=(StateT o) FLATBUFFERS_NOEXCEPT {
  std::swap(payload, o.payload);
  return *this;
}

inline StateT *State::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StateT>(new StateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void State::UnPackTo(StateT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = payload(); if (_e) { _o->payload.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->payload[_i]) { _e->Get(_i)->UnPackTo(_o->payload[_i].get(), _resolver); } else { _o->payload[_i] = std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::PayloadT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->payload.resize(0); } }
}

inline ::flatbuffers::Offset<State> State::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateState(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<State> CreateState(::flatbuffers::FlatBufferBuilder &_fbb, const StateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StateT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _payload = _o->payload.size() ? _fbb.CreateVector<::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::Payload>> (_o->payload.size(), [](size_t i, _VectorArgs *__va) { return CreatePayload(*__va->__fbb, __va->__o->payload[i].get(), __va->__rehasher); }, &_va ) : 0;
  return HIVE::Commons::Flatbuffers::Generated::CreateState(
      _fbb,
      _payload);
}

inline bool VerifyCommandUnion(::flatbuffers::Verifier &verifier, const void *obj, CommandUnion type) {
  switch (type) {
    case CommandUnion_NONE: {
      return true;
    }
    case CommandUnion_Owner: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Owner *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CommandUnion_MoveTo: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::MoveTo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CommandUnion_Sleep: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Sleep *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyCommandUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCommandUnion(
        verifier,  values->Get(i), types->GetEnum<CommandUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline void *CommandUnionUnion::UnPack(const void *obj, CommandUnion type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case CommandUnion_Owner: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Owner *>(obj);
      return ptr->UnPack(resolver);
    }
    case CommandUnion_MoveTo: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::MoveTo *>(obj);
      return ptr->UnPack(resolver);
    }
    case CommandUnion_Sleep: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Sleep *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> CommandUnionUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case CommandUnion_Owner: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::OwnerT *>(value);
      return CreateOwner(_fbb, ptr, _rehasher).Union();
    }
    case CommandUnion_MoveTo: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::MoveToT *>(value);
      return CreateMoveTo(_fbb, ptr, _rehasher).Union();
    }
    case CommandUnion_Sleep: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::SleepT *>(value);
      return CreateSleep(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline CommandUnionUnion::CommandUnionUnion(const CommandUnionUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case CommandUnion_Owner: {
      value = new HIVE::Commons::Flatbuffers::Generated::OwnerT(*reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::OwnerT *>(u.value));
      break;
    }
    case CommandUnion_MoveTo: {
      value = new HIVE::Commons::Flatbuffers::Generated::MoveToT(*reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::MoveToT *>(u.value));
      break;
    }
    case CommandUnion_Sleep: {
      value = new HIVE::Commons::Flatbuffers::Generated::SleepT(*reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::SleepT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void CommandUnionUnion::Reset() {
  switch (type) {
    case CommandUnion_Owner: {
      auto ptr = reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::OwnerT *>(value);
      delete ptr;
      break;
    }
    case CommandUnion_MoveTo: {
      auto ptr = reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::MoveToT *>(value);
      delete ptr;
      break;
    }
    case CommandUnion_Sleep: {
      auto ptr = reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::SleepT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = CommandUnion_NONE;
}

inline bool VerifyEntityUnion(::flatbuffers::Verifier &verifier, const void *obj, EntityUnion type) {
  switch (type) {
    case EntityUnion_NONE: {
      return true;
    }
    case EntityUnion_Generic: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Generic *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EntityUnion_Robot: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Robot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EntityUnion_Headset: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Headset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EntityUnion_Presenter: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Presenter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EntityUnion_Geometry: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Geometry *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EntityUnion_Observer: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Observer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EntityUnion_Command: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Command *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EntityUnion_Node: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Node *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyEntityUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEntityUnion(
        verifier,  values->Get(i), types->GetEnum<EntityUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline void *EntityUnionUnion::UnPack(const void *obj, EntityUnion type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case EntityUnion_Generic: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Generic *>(obj);
      return ptr->UnPack(resolver);
    }
    case EntityUnion_Robot: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Robot *>(obj);
      return ptr->UnPack(resolver);
    }
    case EntityUnion_Headset: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Headset *>(obj);
      return ptr->UnPack(resolver);
    }
    case EntityUnion_Presenter: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Presenter *>(obj);
      return ptr->UnPack(resolver);
    }
    case EntityUnion_Geometry: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Geometry *>(obj);
      return ptr->UnPack(resolver);
    }
    case EntityUnion_Observer: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Observer *>(obj);
      return ptr->UnPack(resolver);
    }
    case EntityUnion_Command: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Command *>(obj);
      return ptr->UnPack(resolver);
    }
    case EntityUnion_Node: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::Node *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> EntityUnionUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case EntityUnion_Generic: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::GenericT *>(value);
      return CreateGeneric(_fbb, ptr, _rehasher).Union();
    }
    case EntityUnion_Robot: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::RobotT *>(value);
      return CreateRobot(_fbb, ptr, _rehasher).Union();
    }
    case EntityUnion_Headset: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::HeadsetT *>(value);
      return CreateHeadset(_fbb, ptr, _rehasher).Union();
    }
    case EntityUnion_Presenter: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::PresenterT *>(value);
      return CreatePresenter(_fbb, ptr, _rehasher).Union();
    }
    case EntityUnion_Geometry: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::GeometryT *>(value);
      return CreateGeometry(_fbb, ptr, _rehasher).Union();
    }
    case EntityUnion_Observer: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::ObserverT *>(value);
      return CreateObserver(_fbb, ptr, _rehasher).Union();
    }
    case EntityUnion_Command: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::CommandT *>(value);
      return CreateCommand(_fbb, ptr, _rehasher).Union();
    }
    case EntityUnion_Node: {
      auto ptr = reinterpret_cast<const HIVE::Commons::Flatbuffers::Generated::NodeT *>(value);
      return CreateNode(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline EntityUnionUnion::EntityUnionUnion(const EntityUnionUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case EntityUnion_Generic: {
      value = new HIVE::Commons::Flatbuffers::Generated::GenericT(*reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::GenericT *>(u.value));
      break;
    }
    case EntityUnion_Robot: {
      value = new HIVE::Commons::Flatbuffers::Generated::RobotT(*reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::RobotT *>(u.value));
      break;
    }
    case EntityUnion_Headset: {
      value = new HIVE::Commons::Flatbuffers::Generated::HeadsetT(*reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::HeadsetT *>(u.value));
      break;
    }
    case EntityUnion_Presenter: {
      value = new HIVE::Commons::Flatbuffers::Generated::PresenterT(*reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::PresenterT *>(u.value));
      break;
    }
    case EntityUnion_Geometry: {
      value = new HIVE::Commons::Flatbuffers::Generated::GeometryT(*reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::GeometryT *>(u.value));
      break;
    }
    case EntityUnion_Observer: {
      value = new HIVE::Commons::Flatbuffers::Generated::ObserverT(*reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::ObserverT *>(u.value));
      break;
    }
    case EntityUnion_Command: {
      value = new HIVE::Commons::Flatbuffers::Generated::CommandT(*reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::CommandT *>(u.value));
      break;
    }
    case EntityUnion_Node: {
      value = new HIVE::Commons::Flatbuffers::Generated::NodeT(*reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::NodeT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void EntityUnionUnion::Reset() {
  switch (type) {
    case EntityUnion_Generic: {
      auto ptr = reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::GenericT *>(value);
      delete ptr;
      break;
    }
    case EntityUnion_Robot: {
      auto ptr = reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::RobotT *>(value);
      delete ptr;
      break;
    }
    case EntityUnion_Headset: {
      auto ptr = reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::HeadsetT *>(value);
      delete ptr;
      break;
    }
    case EntityUnion_Presenter: {
      auto ptr = reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::PresenterT *>(value);
      delete ptr;
      break;
    }
    case EntityUnion_Geometry: {
      auto ptr = reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::GeometryT *>(value);
      delete ptr;
      break;
    }
    case EntityUnion_Observer: {
      auto ptr = reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::ObserverT *>(value);
      delete ptr;
      break;
    }
    case EntityUnion_Command: {
      auto ptr = reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::CommandT *>(value);
      delete ptr;
      break;
    }
    case EntityUnion_Node: {
      auto ptr = reinterpret_cast<HIVE::Commons::Flatbuffers::Generated::NodeT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = EntityUnion_NONE;
}

inline const HIVE::Commons::Flatbuffers::Generated::State *GetState(const void *buf) {
  return ::flatbuffers::GetRoot<HIVE::Commons::Flatbuffers::Generated::State>(buf);
}

inline const HIVE::Commons::Flatbuffers::Generated::State *GetSizePrefixedState(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<HIVE::Commons::Flatbuffers::Generated::State>(buf);
}

inline State *GetMutableState(void *buf) {
  return ::flatbuffers::GetMutableRoot<State>(buf);
}

inline HIVE::Commons::Flatbuffers::Generated::State *GetMutableSizePrefixedState(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<HIVE::Commons::Flatbuffers::Generated::State>(buf);
}

inline bool VerifyStateBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<HIVE::Commons::Flatbuffers::Generated::State>(nullptr);
}

inline bool VerifySizePrefixedStateBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<HIVE::Commons::Flatbuffers::Generated::State>(nullptr);
}

inline void FinishStateBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::State> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedStateBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<HIVE::Commons::Flatbuffers::Generated::State> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::StateT> UnPackState(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::StateT>(GetState(buf)->UnPack(res));
}

inline std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::StateT> UnPackSizePrefixedState(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<HIVE::Commons::Flatbuffers::Generated::StateT>(GetSizePrefixedState(buf)->UnPack(res));
}

}  // namespace Generated
}  // namespace Flatbuffers
}  // namespace Commons
}  // namespace HIVE

#endif  // FLATBUFFERS_GENERATED_COMMONS_HIVE_COMMONS_FLATBUFFERS_GENERATED_H_
